
    - name: Ensure default VPC present (when using default)
      amazon.aws.ec2_vpc_net_info:
        filters:
          isDefault: true
        region: "{{ aws_region }}"
      register: vpc_info
      when: use_default_vpc | default(true)

    - name: Set VPC ID from default
      ansible.builtin.set_fact:
        vpc_id: "{{ vpc_info.vpcs[0].vpc_id }}"
      when: use_default_vpc | default(true)

    - name: Get subnets for this VPC
      amazon.aws.ec2_vpc_subnet_info:
        filters:
          vpc-id: "{{ vpc_id }}"
        region: "{{ aws_region }}"
      register: vpc_subnets

    - name: Build subnet list for ALB/ASG
      ansible.builtin.set_fact:
        asg_subnets: "{{ vpc_subnets.subnets | map(attribute='subnet_id') | list }}"

    - name: Create ALB Security Group
      amazon.aws.ec2_group:
        name: "{{ alb_sg_name }}"
        description: "SG for ALB"
        vpc_id: "{{ vpc_id }}"
        region: "{{ aws_region }}"
        state: present
        tags: "{{ tags_common }}"
      register: alb_sg

    - name: Open HTTP 80 to world on ALB SG
      amazon.aws.ec2_security_group:
        name: "{{ alb_sg_name }}"
        vpc_id: "{{ vpc_id }}"
        description: "SG for ALB"
        region: "{{ aws_region }}"
        rules:
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow all egress"
        rules_egress:
          - proto: -1
            from_port: 0
            to_port: 0
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow all egress"

    - name: Create Instances SG (for ASG instances)
      amazon.aws.ec2_group:
        name: "{{ instance_sg_name }}"
        description: "SG for ASG instances"
        vpc_id: "{{ vpc_id }}"
        region: "{{ aws_region }}"
        state: present
        tags: "{{ tags_common }}"
      register: inst_sg

    - name: Allow HTTP from ALB to instances
      amazon.aws.ec2_security_group:
        name: "{{ instance_sg_name }}"
        vpc_id: "{{ vpc_id }}"
        description: "SG for ASG instances HTTP"
        region: "{{ aws_region }}"
        rules:
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow HTTP from anywhere"
        rules_egress:
          - proto: -1
            from_port: 0
            to_port: 0
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow all egress"

    - name: Ensure RDS SG allows MySQL ingress from instances SG (optional)
      amazon.aws.ec2_security_group:
        name: "{{ rds_vpc_security_group_name }}"
        vpc_id: "{{ vpc_id }}"
        description: "RDS SG ingress from ASG SG"
        region: "{{ aws_region }}"
        rules:
          - proto: tcp
            from_port: 3306
            to_port: 3306
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow MySQL from ASG SG"
        rules_egress:
          - proto: -1
            from_port: 0
            to_port: 0
            cidr_ip: 0.0.0.0/0
      failed_when: false

    # ALB + TG
    - name: Create ALB
      amazon.aws.elb_application_lb:
        name: "{{ alb_name }}"
        state: present
        subnets: "{{ asg_subnets }}"
        security_groups: ["{{ alb_sg.group_id }}"]
        scheme: internet-facing
        region: "{{ aws_region }}"
        tags: "{{ tags_common }}"
      register: alb

    - name: Create Target Group
      community.aws.elb_target_group:
        name: "{{ tg_name }}"
        protocol: HTTP
        port: 80
        vpc_id: "{{ vpc_id }}"
        health_check_protocol: HTTP
        health_check_path: "{{ health_check_path }}"
        target_type: instance
        state: present
        region: "{{ aws_region }}"
        tags: "{{ tags_common }}"
      register: tg

    # Listener via AWS CLI (fallback)
    - name: Describe existing ALB listeners via CLI
      ansible.builtin.command: >
        aws elbv2 describe-listeners
        --region {{ aws_region }}
        --load-balancer-arn {{ alb.load_balancer_arn }}
      register: listeners_info
      changed_when: false
      failed_when: listeners_info.rc != 0

    - name: Parse listeners JSON
      ansible.builtin.set_fact:
        existing_listeners: "{{ (listeners_info.stdout | from_json).Listeners | default([]) }}"

    - name: Check if desired HTTP listener exists on the specified port
      ansible.builtin.set_fact:
        listener_exists: >-
          {{ existing_listeners
              | selectattr('Port', 'equalto', alb_listener_port)
              | selectattr('Protocol', 'equalto', 'HTTP')
              | list | length > 0 }}

    - name: Create ALB Listener via CLI (fallback)
      ansible.builtin.command: >
        aws elbv2 create-listener
        --region {{ aws_region }}
        --load-balancer-arn {{ alb.load_balancer_arn }}
        --protocol HTTP
        --port {{ alb_listener_port }}
        --default-actions Type=forward,TargetGroupArn={{ tg.target_group_arn }}
      register: create_listener
      when: not listener_exists
      changed_when: create_listener.rc == 0
      failed_when: create_listener.rc != 0 and ('DuplicateListener' not in (create_listener.stderr | default('')))

    # Renderização local dos seus templates e arquivo envconfig
    - name: Render index.html from template (local)
      ansible.builtin.template:
        src: "{{ tpl_index_src }}"
        dest: "/tmp/index.html"
      delegate_to: localhost

    - name: Read rendered index.html
      ansible.builtin.slurp:
        src: "/tmp/index.html"
      register: rendered_index
      delegate_to: localhost

    - name: Render nginx site config from template (local)
      ansible.builtin.template:
        src: "{{ tpl_nginx_src }}"
        dest: "/tmp/nginx_site.conf"
      delegate_to: localhost

    - name: Read rendered nginx config
      ansible.builtin.slurp:
        src: "/tmp/nginx_site.conf"
      register: rendered_nginx
      delegate_to: localhost

    # Build user_data incorporando os conteúdos renderizados
    - name: Build user_data with rendered templates
      ansible.builtin.set_fact:
        lt_user_data: |
          #!/bin/bash
          set -euxo pipefail
          export DEBIAN_FRONTEND=noninteractive
          apt-get update
          apt-get install -y nginx

          mkdir -p /var/www/html
          cat > /var/www/html/index.html << 'EOF_INDEX'
          {{ rendered_index.content | b64decode }}
          EOF_INDEX

          mkdir -p /etc/myapp
          cat > /etc/myapp/envconfig << 'EOF_ENV'
          {{ envconfig_file.content | b64decode }}
          EOF_ENV

          # Configurar site do nginx
          cat > /etc/nginx/sites-available/default << 'EOF_NGINX'
          {{ rendered_nginx.content | b64decode }}
          EOF_NGINX

          systemctl enable nginx
          systemctl restart nginx

    # Launch Template com community.aws (compatível)
    - name: Create/Update Launch Template (community.aws)
      community.aws.ec2_launch_template:
        name: "{{ lt_name }}"
        region: "{{ aws_region }}"
        image_id: "{{ ec2_ami }}"
        instance_type: "{{ ec2_instance_type }}"
        key_name: "{{ ec2_key_name | default(omit) }}"
        security_group_ids:
          - "{{ inst_sg.group_id }}"
        user_data: "{{ lt_user_data | b64encode }}"
        tag_specifications:
          - resource_type: instance
            tags:
              Name: "{{ asg_name }}-instance"
              Project: "{{ tags_common.Project }}"
              Env: "{{ tags_common.Env }}"
              Owner: "{{ tags_common.Owner }}"
          - resource_type: volume
            tags:
              Project: "{{ tags_common.Project }}"
              Env: "{{ tags_common.Env }}"
              Owner: "{{ tags_common.Owner }}"
      register: lt

    # ASG com min 2 instâncias
    - name: Create/Update ASG
      amazon.aws.autoscaling_group:
        name: "{{ asg_name }}"
        region: "{{ aws_region }}"
        launch_template:
          launch_template_name: "{{ lt_name }}"
          version: "$Latest"
        desired_capacity: "{{ desired_capacity }}"
        min_size: "{{ min_size }}"
        max_size: "{{ max_size }}"
        vpc_zone_identifier: "{{ asg_subnets | join(',') }}"
        target_group_arns:
          - "{{ tg.target_group_arn }}"
        health_check_type: EC2
        health_check_period: 60
        state: present
        tags:
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Name
            value: "{{ asg_name }}-instance"
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Project
            value: "{{ tags_common.Project }}"
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Env
            value: "{{ tags_common.Env }}"
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Owner
            value: "{{ tags_common.Owner }}"

    - name: Show ALB DNS
      ansible.builtin.debug:
        msg:
          alb_name: "{{ alb_name }}"
          alb_dns_name: "{{ alb.dns_name }}"
          alb_arn: "{{ alb.load_balancer_arn }}"
          tg_arn: "{{ tg.target_group_arn }}"
          access_url: "http://{{ alb.dns_name }}/"
# Busca a VPC default na região (quando estiver usando a VPC padrão da conta)
    - name: Ensure default VPC present (when using default)
      amazon.aws.ec2_vpc_net_info:
        filters:
          isDefault: true
        region: "{{ aws_region }}"
      register: vpc_info
      when: use_default_vpc | default(true)

    # Define a variável vpc_id com a VPC default encontrada
    - name: Set VPC ID from default
      ansible.builtin.set_fact:
        vpc_id: "{{ vpc_info.vpcs[0].vpc_id }}"
      when: use_default_vpc | default(true)

    # Lista as subnets existentes da VPC escolhida
    - name: Get subnets for this VPC
      amazon.aws.ec2_vpc_subnet_info:
        filters:
          vpc-id: "{{ vpc_id }}"
        region: "{{ aws_region }}"
      register: vpc_subnets

    # Cria uma lista simples de subnet_ids para uso no ALB/ASG
    - name: Build subnet list for ALB/ASG
      ansible.builtin.set_fact:
        asg_subnets: "{{ vpc_subnets.subnets | map(attribute='subnet_id') | list }}"

    # Cria o Security Group do ALB (sem regras ainda)
    - name: Create ALB Security Group
      amazon.aws.ec2_group:
        name: "{{ alb_sg_name }}"
        description: "SG for ALB"
        vpc_id: "{{ vpc_id }}"
        region: "{{ aws_region }}"
        state: present
        tags: "{{ tags_common }}"
      register: alb_sg

    # Abre porta 80 (HTTP) do mundo para o ALB e libera egress irrestrito
    - name: Open HTTP 80 to world on ALB SG
      amazon.aws.ec2_security_group:
        name: "{{ alb_sg_name }}"
        vpc_id: "{{ vpc_id }}"
        description: "SG for ALB"
        region: "{{ aws_region }}"
        rules:
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow all egress"
        rules_egress:
          - proto: -1
            from_port: 0
            to_port: 0
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow all egress"

    # Cria o Security Group para as instâncias do ASG
    - name: Create Instances SG (for ASG instances)
      amazon.aws.ec2_group:
        name: "{{ instance_sg_name }}"
        description: "SG for ASG instances"
        vpc_id: "{{ vpc_id }}"
        region: "{{ aws_region }}"
        state: present
        tags: "{{ tags_common }}"
      register: inst_sg

    # Abre HTTP 80 nas instâncias (aqui está aberto para qualquer origem; pode-se restringir ao SG do ALB)
    - name: Allow HTTP from ALB to instances
      amazon.aws.ec2_security_group:
        name: "{{ instance_sg_name }}"
        vpc_id: "{{ vpc_id }}"
        description: "SG for ASG instances HTTP"
        region: "{{ aws_region }}"
        rules:
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow HTTP from anywhere"
        rules_egress:
          - proto: -1
            from_port: 0
            to_port: 0
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow all egress"

    # (Opcional) Garante que o SG do RDS permita MySQL (3306). Aqui está aberto para o mundo; ideal é restringir ao SG das instâncias
    - name: Ensure RDS SG allows MySQL ingress from instances SG (optional)
      amazon.aws.ec2_security_group:
        name: "{{ rds_vpc_security_group_name }}"
        vpc_id: "{{ vpc_id }}"
        description: "RDS SG ingress from ASG SG"
        region: "{{ aws_region }}"
        rules:
          - proto: tcp
            from_port: 3306
            to_port: 3306
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow MySQL from ASG SG"
        rules_egress:
          - proto: -1
            from_port: 0
            to_port: 0
            cidr_ip: 0.0.0.0/0
      failed_when: false

    # Cria o Application Load Balancer (internet-facing) nas subnets informadas
    - name: Create ALB
      amazon.aws.elb_application_lb:
        name: "{{ alb_name }}"
        state: present
        subnets: "{{ asg_subnets }}"
        security_groups: ["{{ alb_sg.group_id }}"]
        scheme: internet-facing
        region: "{{ aws_region }}"
        tags: "{{ tags_common }}"
      register: alb

    # Cria o Target Group HTTP:80 com health check em path definido, tipo "instance"
    - name: Create Target Group
      community.aws.elb_target_group:
        name: "{{ tg_name }}"
        protocol: HTTP
        port: 80
        vpc_id: "{{ vpc_id }}"
        health_check_protocol: HTTP
        health_check_path: "{{ health_check_path }}"
        target_type: instance
        state: present
        region: "{{ aws_region }}"
        tags: "{{ tags_common }}"
      register: tg

    # Usa AWS CLI para descrever listeners existentes do ALB (fallback quando módulo não é usado)
    - name: Describe existing ALB listeners via CLI
      ansible.builtin.command: >
        aws elbv2 describe-listeners
        --region {{ aws_region }}
        --load-balancer-arn {{ alb.load_balancer_arn }}
      register: listeners_info
      changed_when: false
      failed_when: listeners_info.rc != 0

    # Converte o JSON de saída em lista de listeners
    - name: Parse listeners JSON
      ansible.builtin.set_fact:
        existing_listeners: "{{ (listeners_info.stdout | from_json).Listeners | default([]) }}"

    # Verifica se já existe um listener HTTP na porta desejada
    - name: Check if desired HTTP listener exists on the specified port
      ansible.builtin.set_fact:
        listener_exists: >-
          {{ existing_listeners
              | selectattr('Port', 'equalto', alb_listener_port)
              | selectattr('Protocol', 'equalto', 'HTTP')
              | list | length > 0 }}

    # Cria o listener HTTP apontando para o Target Group (apenas se não existir)
    - name: Create ALB Listener via CLI (fallback)
      ansible.builtin.command: >
        aws elbv2 create-listener
        --region {{ aws_region }}
        --load-balancer-arn {{ alb.load_balancer_arn }}
        --protocol HTTP
        --port {{ alb_listener_port }}
        --default-actions Type=forward,TargetGroupArn={{ tg.target_group_arn }}
      register: create_listener
      when: not listener_exists
      changed_when: create_listener.rc == 0
      failed_when: create_listener.rc != 0 and ('DuplicateListener' not in (create_listener.stderr | default('')))

    # Renderiza o index.html localmente a partir de um template Jinja2
    - name: Render index.html from template (local)
      ansible.builtin.template:
        src: "{{ tpl_index_src }}"
        dest: "/tmp/index.html"
      delegate_to: localhost

    # Lê o arquivo renderizado (base64) para injetar no user_data
    - name: Read rendered index.html
      ansible.builtin.slurp:
        src: "/tmp/index.html"
      register: rendered_index
      delegate_to: localhost

    # Renderiza a configuração do site Nginx localmente
    - name: Render nginx site config from template (local)
      ansible.builtin.template:
        src: "{{ tpl_nginx_src }}"
        dest: "/tmp/nginx_site.conf"
      delegate_to: localhost

    # Lê a config do Nginx (base64) para injetar no user_data
    - name: Read rendered nginx config
      ansible.builtin.slurp:
        src: "/tmp/nginx_site.conf"
      register: rendered_nginx
      delegate_to: localhost

    # Monta o script user_data que instala Nginx, publica index.html e aplica config do Nginx
    - name: Build user_data with rendered templates
      ansible.builtin.set_fact:
        lt_user_data: |
          #!/bin/bash
          set -euxo pipefail
          export DEBIAN_FRONTEND=noninteractive
          apt-get update
          apt-get install -y nginx

          mkdir -p /var/www/html
          cat > /var/www/html/index.html << 'EOF_INDEX'
          {{ rendered_index.content | b64decode }}
          EOF_INDEX

          mkdir -p /etc/myapp

          # Configurar site do nginx
          cat > /etc/nginx/sites-available/default << 'EOF_NGINX'
          {{ rendered_nginx.content | b64decode }}
          EOF_NGINX

          systemctl enable nginx
          systemctl restart nginx

    # Cria/Atualiza o Launch Template via community.aws, incluindo user_data e SG das instâncias
    # Aqui tags no LT serão do próprio template, não necessariamente propagadas à instância (módulo não suporta tag_specifications)
    - name: Create/Update Launch Template (community.aws)
      community.aws.ec2_launch_template:
        name: "{{ lt_name }}"
        region: "{{ aws_region }}"
        image_id: "{{ ec2_ami }}"
        instance_type: "{{ ec2_instance_type }}"
        key_name: "{{ ec2_key_name | default(omit) }}"
        security_group_ids:
          - "{{ inst_sg.group_id }}"
        user_data: "{{ lt_user_data | b64encode }}"
        tags:
          Project: "{{ tags_common.Project }}"
          Env: "{{ tags_common.Env }}"
          Owner: "{{ tags_common.Owner }}"
          Name: "{{ asg_name }}-site-instance"
      register: lt

    # Cria/Atualiza o Auto Scaling Group com capacidade desejada e anexa ao Target Group do ALB
    # As tags abaixo (com propagate_at_launch: true) serão aplicadas às instâncias lançadas pelo ASG
    - name: Create/Update ASG
      amazon.aws.autoscaling_group:
        name: "{{ asg_name }}"
        region: "{{ aws_region }}"
        launch_template:
          launch_template_name: "{{ lt_name }}"
          version: "$Latest"
        desired_capacity: "{{ desired_capacity }}"
        min_size: "{{ min_size }}"
        max_size: "{{ max_size }}"
        vpc_zone_identifier: "{{ asg_subnets | join(',') }}"
        target_group_arns:
          - "{{ tg.target_group_arn }}"
        health_check_type: EC2
        health_check_period: 60
        state: present
        tags:
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Name
            value: "{{ asg_name }}-instance"
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Project
            value: "{{ tags_common.Project }}"
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Env
            value: "{{ tags_common.Env }}"
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Owner
            value: "{{ tags_common.Owner }}"

    # Exibe informações úteis do ALB para acesso rápido
    - name: Show ALB DNS
      ansible.builtin.debug:
        msg:
          alb_name: "{{ alb_name }}"
          alb_dns_name: "{{ alb.dns_name }}"
          alb_arn: "{{ alb.load_balancer_arn }}"
          tg_arn: "{{ tg.target_group_arn }}"
          access_url: "http://{{ alb.dns_name }}/"
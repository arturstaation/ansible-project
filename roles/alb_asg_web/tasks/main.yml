---
- name: Provisionar ALB, Target Group, Listener (via CLI), SGs, Launch Template e ASG
  hosts: localhost
  connection: local
  gather_facts: false

  collections:
    - amazon.aws
    - community.aws

  vars:
    # VARIÁVEIS DO SEU AMBIENTE
    aws_region: "us-east-1"

    tags_common:
      Project: "TrabalhoDupla"
      Env: "lab"
      Owner: "voce"

    # VPC
    use_default_vpc: true
    vpc_id: ""
    subnet_id: ""
    security_group_name: "td-web-sg"              # SG de EC2 "single" (não usado no ASG; mantido caso você reutilize)
    security_group_description: "SG Web EC2 (80/22) e egress"

    # ALB/ASG variáveis
    alb_name: "td-alb"
    alb_sg_name: "td-alb-sg"
    tg_name: "td-tg"
    asg_name: "td-asg"
    lt_name: "td-launch-template"
    desired_capacity: 2
    min_size: 1
    max_size: 3
    alb_listener_port: 80
    health_check_path: "/"
    instance_sg_name: "td-asg-instances-sg"

    # EC2/Launch Template
    ec2_ami: "ami-0360c520857e3138f"        # Ubuntu 22.04 LTS na us-east-1 (ajuste se necessário)
    ec2_instance_type: "t3.micro"
    ec2_key_name: "TrabalhoDupla"

    # Site via user_data para as instâncias do ASG
    site_version: "1.0.0"
    site_title: "Site Estático - TrabalhoDupla"
    site_message: "Deploy inicial via Ansible"
    nginx_server_name: "_"
    nginx_listen_port: 80

    # RDS (opcional)
    rds_vpc_security_group_name: "td-rds-sg"

  tasks:
    - name: Ensure default VPC present (when using default)
      amazon.aws.ec2_vpc_net_info:
        filters:
          isDefault: true
        region: "{{ aws_region }}"
      register: vpc_info
      when: use_default_vpc | default(true)

    - name: Set VPC ID from default
      ansible.builtin.set_fact:
        vpc_id: "{{ vpc_info.vpcs[0].vpc_id }}"
      when: use_default_vpc | default(true)

    - name: Get subnets for this VPC
      amazon.aws.ec2_vpc_subnet_info:
        filters:
          vpc-id: "{{ vpc_id }}"
        region: "{{ aws_region }}"
      register: vpc_subnets

    - name: Build subnet list for ALB/ASG
      ansible.builtin.set_fact:
        asg_subnets: "{{ vpc_subnets.subnets | map(attribute='subnet_id') | list }}"

    - name: Create ALB Security Group
      amazon.aws.ec2_group:
        name: "{{ alb_sg_name }}"
        description: "SG for ALB"
        vpc_id: "{{ vpc_id }}"
        region: "{{ aws_region }}"
        state: present
        tags: "{{ tags_common }}"
      register: alb_sg

    - name: Open HTTP 80 to world on ALB SG
      amazon.aws.ec2_security_group:
        name: "{{ alb_sg_name }}"
        vpc_id: "{{ vpc_id }}"
        description: "SG for ALB"
        region: "{{ aws_region }}"
        rules:
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: 0.0.0.0/0
        rules_egress:
          - proto: -1
            from_port: 0
            to_port: 0
            cidr_ip: 0.0.0.0/0

    - name: Create Instances SG (for ASG instances)
      amazon.aws.ec2_group:
        name: "{{ instance_sg_name }}"
        description: "SG for ASG instances"
        vpc_id: "{{ vpc_id }}"
        region: "{{ aws_region }}"
        state: present
        tags: "{{ tags_common }}"
      register: inst_sg

    - name: Allow HTTP from ALB to instances
      amazon.aws.ec2_security_group:
        name: "{{ instance_sg_name }}"
        vpc_id: "{{ vpc_id }}"
        description: "SG for ALB"
        region: "{{ aws_region }}"
        rules:
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow HTTP from anywhere"
        rules_egress:
          - proto: -1
            from_port: 0
            to_port: 0
            cidr_ip: 0.0.0.0/0
            rule_desc: "Allow all egress"

    - name: Ensure RDS SG allows MySQL ingress from instances SG (optional)
      amazon.aws.ec2_security_group:
        name: "{{ rds_vpc_security_group_name }}"
        vpc_id: "{{ vpc_id }}"
        description: "SG for ALB"
        region: "{{ aws_region }}"
        rules:
          - proto: tcp
            from_port: 3306
            to_port: 3306
            group_pairs:
              - group_id: "{{ inst_sg.group_id }}"
        rules_egress:
          - proto: -1
            from_port: 0
            to_port: 0
            cidr_ip: 0.0.0.0/0
      failed_when: false

    # ALB + TG com módulos amazon.aws
    - name: Create ALB
      amazon.aws.elb_application_lb:
        name: "{{ alb_name }}"
        state: present
        subnets: "{{ asg_subnets }}"
        security_groups: ["{{ alb_sg.group_id }}"]
        scheme: internet-facing
        region: "{{ aws_region }}"
        tags: "{{ tags_common }}"
      register: alb

    - name: Create Target Group
      community.aws.elb_target_group:
        name: "{{ tg_name }}"
        protocol: HTTP
        port: 80
        vpc_id: "{{ vpc_id }}"
        health_check_protocol: HTTP
        health_check_path: "{{ health_check_path }}"
        target_type: instance
        state: present
        region: "{{ aws_region }}"
        tags: "{{ tags_common }}"
      register: tg

    # Listener via AWS CLI (fallback)
    - name: Describe existing ALB listeners via CLI
      ansible.builtin.command: >
        aws elbv2 describe-listeners
        --region {{ aws_region }}
        --load-balancer-arn {{ alb.load_balancer_arn }}
      register: listeners_info
      changed_when: false
      failed_when: listeners_info.rc != 0

    - name: Parse listeners JSON
      ansible.builtin.set_fact:
        existing_listeners: "{{ (listeners_info.stdout | from_json).Listeners | default([]) }}"

    - name: Check if desired HTTP listener exists on the specified port
      ansible.builtin.set_fact:
        listener_exists: >-
          {{ existing_listeners
             | selectattr('Port', 'equalto', alb_listener_port)
             | selectattr('Protocol', 'equalto', 'HTTP')
             | list | length > 0 }}

    - name: Create ALB Listener via CLI (fallback)
      ansible.builtin.command: >
        aws elbv2 create-listener
        --region {{ aws_region }}
        --load-balancer-arn {{ alb.load_balancer_arn }}
        --protocol HTTP
        --port {{ alb_listener_port }}
        --default-actions Type=forward,TargetGroupArn={{ tg.target_group_arn }}
      register: create_listener
      when: not listener_exists
      changed_when: create_listener.rc == 0
      failed_when: create_listener.rc != 0 and ('DuplicateListener' not in (create_listener.stderr | default('')))

    # Launch Template com user_data para servir Nginx no boot (Ubuntu 22.04)
    - name: Render user_data inline for LT
      ansible.builtin.set_fact:
        lt_user_data: |
          #!/bin/bash
          set -euxo pipefail
          export DEBIAN_FRONTEND=noninteractive
          apt-get update
          apt-get install -y nginx
          mkdir -p /var/www/html
          cat > /var/www/html/index.html << 'EOF'
          <!doctype html>
          <html>
            <head>
              <meta charset="utf-8">
              <title>{{ site_title }}</title>
              <meta name="viewport" content="width=device-width, initial-scale=1" />
              <style>
                :root { --accent: #0a7; }
                html, body { margin:0; padding:0; font-family: system-ui, Arial, sans-serif; color:#222;}
                .wrap { max-width: 760px; margin: 60px auto; padding: 0 20px; }
                h1 { color: var(--accent); }
                .meta { color:#666; }
              </style>
            </head>
            <body>
              <div class="wrap">
                <h1>{{ site_title }}</h1>
                <p class="meta">Versão: {{ site_version }} — {{ site_message }}</p>
                <p>Instância inicializada pelo Auto Scaling Group com user_data (Ubuntu 22.04).</p>
              </div>
            </body>
          </html>
          EOF
          systemctl enable nginx
          systemctl restart nginx

    - name: Create/Update Launch Template (community.aws)
      community.aws.ec2_launch_template:
        name: "{{ lt_name }}"
        region: "{{ aws_region }}"
        image_id: "{{ ec2_ami }}"
        instance_type: "{{ ec2_instance_type }}"
        key_name: "{{ ec2_key_name | default(omit) }}"
        # Parâmetros de rede suportados pelo módulo community.aws (formato "flat")
        device_index: 0
        groups:
          - "{{ inst_sg.group_id }}"
        # Em geral, deixe subnet/assign public IP para o ASG (vpc_zone_identifier). Descomente se precisar:
        # subnet_id: "{{ asg_subnets[0] }}"
        # associate_public_ip_address: true
        # User data deve ser base64
        user_data: "{{ lt_user_data | b64encode }}"
      register: lt

    - name: Create/Update ASG
      amazon.aws.autoscaling_group:
        name: "{{ asg_name }}"
        region: "{{ aws_region }}"
        launch_template:
          name: "{{ lt_name }}"
        desired_capacity: "{{ desired_capacity }}"
        min_size: "{{ min_size }}"
        max_size: "{{ max_size }}"
        vpc_zone_identifier: "{{ asg_subnets }}"
        target_group_arns:
          - "{{ tg.target_group_arn }}"
        health_check_type: EC2
        state: present
        tags:
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Project
            value: "{{ tags_common.Project }}"
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Env
            value: "{{ tags_common.Env }}"
          - resource_id: "{{ asg_name }}"
            resource_type: auto-scaling-group
            propagate_at_launch: true
            key: Owner
            value: "{{ tags_common.Owner }}"

    - name: Show ALB DNS
      ansible.builtin.debug:
        msg:
          alb_name: "{{ alb_name }}"
          alb_dns_name: "{{ alb.dns_name }}"
          alb_arn: "{{ alb.load_balancer_arn }}"
          tg_arn: "{{ tg.target_group_arn }}"